## 实现的功能总结
在chapter3对应的实验1中，我按照要求实现了一个sys_task_info的系统调用，用来获取正在执行的任务信息。首先为了获取正在运行任务的运行时长，我在每个任务的任务控制块中记录了每个任务第一次被调度的时间，之后查询时就可以将当前时间减去该值获得运行时长；对于获取系统调用次数的功能，我在任务控制块中记录了每个任务的各种系统调用的次数，之后就可以直接查询；对于获取任务状态，则直接添加一个函数，从任务控制块原有的字段中获取。将上述获得的信息进行整合，返回所需要的值即可。

## 简答作业
深入理解trap.S中两个函数__alltraps和__restore的作用，并回答如下问题:
1. L40: 刚进入__restore时, a0代表了什么值。请指出__restore的两种使用场景。
    由于在trap_handler中将传入的cx原样返回, 所以刚进入__restore的时候,a0寄存器的值和调用trap_handler
    之前的一样，仍然指向分配Trap上下文之后的内核栈栈顶，和此时的sp的值相同。在另外一种使用场景下，此时a0也同样指向内核栈压入Trap上下文之后的栈顶。
    一种使用场景是在处理完Trap之后，通过使用__restore来恢复寄存器的值，从而回到U用户态；另外一种使用场景是
    可以用来切换应用程序，通过复用__restore的代码，在内核栈上压入一个为启动应用程序而特殊构造的Trap上下文，
    通过__restore函数，让寄存器的值到达启动应用程序所需要的上下文状态。

2. L43-L48: 这几行汇编代码特殊处理了哪些寄存器? 这些寄存器的值对于进入用户态有何意义? 请分别解释。
    处理了寄存器sstatus,sepc,sscratch. sstatus中的SPP等字段记录了Trap发生之前CPU所处的特权级，所以该寄存器的值
    起到正确切换回特权级的作用；sepc中记录着Trap发生之前执行的最后一条指令的地址，该寄存器的值起着正确恢复程序执行流的作用；sscratch此时保存着用户栈的信息，帮助正确恢复指向的用户栈。

3. L50-L56: 为何跳过了x2和x4?
    跳过x4是因为x4寄存器在一般情况下不会被用到，所以无需保存。跳过x2是因为x2是sp，sp在__alltraps中进行sp
    寄存器和sscratch寄存器的值交换之后指向内核栈，用户栈的栈指针保存早sscratch中，必须要通过csrr指令读到通用
    寄存器中才可以使用，所以考虑保存其他通用寄存器，腾出空间。

4. L60: 该指令之后，sp和sscratch中的值分别有什么意义?
    该指令之后，sp重新指向用户栈栈顶, sscratch中保存进入Trap之前的状态并且指向内核栈栈顶。

5. __restore: 中发生状态切换在哪一个指令? 为何该指令执行之后会进入用户态?
    __restore中发生状态切换在sret指令。因为执行sret指令的时候，CPU会将当前的特权级按照sstatus的SPP字段设置为U，
    也就是设置为U用户态，同时CPU会跳转到sepc寄存器指向的那条指令，然后继续执行，也就是说执行sret指令之后切换回用户态。

6. L13: 该指令之后，sp和sscratch中的值分别有什么意义?
    该指令之后，sp指内核栈，sscratch指向用户栈

7. 从U态进入S态是哪一条指令发生的?
    ecall指令

## 荣誉准则
1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
    我自己
2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。